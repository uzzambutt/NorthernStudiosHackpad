# ---------------------------------------------------------
# northernStudiosâ„¢ Sim Deck Firmware - ENGINEER EDITION
# Developer: Muhammad Uzzam Butt
# License: CC BY-NC-SA 4.0
# Version: v5.3 (Power Management Update)
# ---------------------------------------------------------

import board
import busio
import microcontroller
import gc
import adafruit_ssd1306
import neopixel
import time
import rotaryio
from kmk.kmk_keyboard import KMKKeyboard
from kmk.keys import KC
from kmk.scanners.keypad import KeysScanner
from kmk.modules.layers import Layers
from kmk.extensions.media_keys import MediaKeys
from kmk.extensions import Extension

# --- CONFIG ---
VERSION = "v5.3"
DWELL_TIME = 2.0  
RGB_SPEED = 0.2 
DIM_TIMEOUT = 120    # Dim screen after 2 min
OFF_TIMEOUT = 600   # Turn off screen after 10 mins

# --- BITMAPS ---
PLANE_BITMAP = bytearray([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,0x00,0x03,0xc0,0x00,0x00,0x03,0xc0,0x00,0x00,0x03,0xc0,0x00,0x00,0x03,0xc0,0x00,0x00,0x03,0xc0,0x00,0x00,0x03,0xc0,0x00,0x00,0x03,0xc0,0x00,0x00,0x03,0xc0,0x00,0x00,0x03,0xc0,0x00,0x00,0x0f,0xf0,0x00,0x00,0x1f,0xf8,0x00,0x00,0x7f,0xfe,0x00,0x00,0xff,0xff,0x00,0x01,0xff,0xff,0x80,0x07,0xfb,0xdf,0xe0,0x0f,0xc3,0xc3,0xf0,0x0c,0x03,0xc0,0x30,0x00,0x03,0xc0,0x00,0x00,0x03,0xc0,0x00,0x00,0x07,0xe0,0x00,0x00,0x07,0xe0,0x00,0x00,0x0d,0xb0,0x00,0x00,0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])
RACE_BITMAP = bytearray([0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x78,0x00,0x08,0xff,0xf8,0x0f,0xff,0xff,0xf8,0x3e,0x7f,0xff,0xc0,0x3a,0xaf,0xff,0x50,0x01,0x00,0xe0,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])
MEDIA_BITMAP = bytearray([0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0x1f,0x01,0xc0,0x00,0x3f,0x01,0xe0,0x00,0x7f,0x00,0xf0,0x00,0x7f,0x00,0x78,0x00,0xff,0x00,0x1c,0x01,0xff,0x0e,0x1c,0xff,0xff,0x0f,0x0e,0xff,0xff,0x07,0x06,0xff,0xff,0x03,0x87,0xff,0xff,0x01,0x87,0xff,0xff,0x01,0xc7,0xff,0xff,0x01,0xc3,0xff,0xff,0x01,0xc3,0xff,0xff,0x01,0xc7,0xff,0xff,0x01,0x87,0xff,0xff,0x03,0x87,0xff,0xff,0x07,0x06,0xff,0xff,0x0f,0x0e,0x01,0xff,0x0e,0x1c,0x00,0xff,0x00,0x1c,0x00,0x7f,0x00,0x78,0x00,0x7f,0x00,0xf0,0x00,0x3f,0x01,0xe0,0x00,0x1f,0x01,0xc0,0x00,0x0f,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00])
STATS_ICON = bytearray([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 
	0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x1f, 0x80, 0x30, 0x00, 0x1f, 0xc0, 
	0x30, 0x00, 0x03, 0xc0, 0x30, 0x00, 0x07, 0xc0, 0x30, 0x00, 0x0e, 0xc0, 0x30, 0x0f, 0x1c, 0xc0, 
	0x30, 0x1f, 0xb8, 0x80, 0x30, 0x39, 0xf0, 0x00, 0x30, 0x70, 0xe0, 0x00, 0x31, 0xc0, 0x00, 0x00, 
	0x33, 0x80, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 
	0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 
	0x3f, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])
GEAR_ICON = bytearray([0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x30, 0x00, 0x00, 0x3c, 0x3c, 0x00, 0x00, 0x3c, 0x3c, 0x00, 
	0x00, 0x3e, 0x7c, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x3f, 0xfc, 0x00, 
	0x06, 0x7f, 0xfe, 0x60, 0x07, 0xff, 0xff, 0xe0, 0x07, 0xfc, 0x3f, 0xe0, 0x0f, 0xf8, 0x0f, 0xf0, 
	0x0f, 0xf0, 0x0f, 0xf0, 0x07, 0xf0, 0x07, 0xe0, 0x01, 0xe0, 0x07, 0x80, 0x01, 0xe0, 0x07, 0x80, 
	0x01, 0xe0, 0x07, 0x80, 0x01, 0xe0, 0x07, 0x80, 0x07, 0xf0, 0x07, 0xe0, 0x0f, 0xf0, 0x0f, 0xf0, 
	0x0f, 0xf8, 0x1f, 0xf0, 0x07, 0xfc, 0x3f, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x06, 0x7f, 0xfe, 0x60, 
	0x00, 0x3f, 0xfc, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x3e, 0x7c, 0x00, 
	0x00, 0x3c, 0x3c, 0x00, 0x00, 0x3c, 0x3c, 0x00, 0x00, 0x0c, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00])

# --- GLOBALS ---
last_activity_time = time.monotonic()
display_state = "ON" # ON, DIM, OFF

class WakeExtension(Extension):
    def on_event(self, keyboard, event, *args, **kwargs):
        global last_activity_time
        if event.pressed: 
            last_activity_time = time.monotonic()
        return True
    def during_bootup(self, *args, **kwargs): pass
    def during_runtime(self, *args, **kwargs): pass
    def on_runtime_enable(self, *args, **kwargs): pass
    def on_runtime_disable(self, *args, **kwargs): pass
    def before_matrix_scan(self, *args, **kwargs): pass
    def after_matrix_scan(self, *args, **kwargs): pass
    def before_hid_send(self, *args, **kwargs): pass
    def after_hid_send(self, *args, **kwargs): pass

# --- HARDWARE ---
pixel = neopixel.NeoPixel(microcontroller.pin.GPIO12, 1, brightness=0.5)
encoder = rotaryio.IncrementalEncoder(board.RX, board.TX)
i2c = busio.I2C(microcontroller.pin.GPIO7, microcontroller.pin.GPIO6)
display = adafruit_ssd1306.SSD1306_I2C(128, 32, i2c)

keyboard = KMKKeyboard()
keyboard.extensions.append(MediaKeys())
keyboard.extensions.append(WakeExtension())

def draw_bitmap_direct(bitmap, x_offset, y_offset):
    for y in range(32):
        for x in range(32):
            byte_index = (y * 4) + (x // 8)
            bit_index = 7 - (x % 8)
            if (bitmap[byte_index] >> bit_index) & 1:
                display.pixel(x + x_offset, y + y_offset, 1)

def startup_screen():
    display.poweron()
    display.contrast(255)
    display.fill(0)
    display.rect(0, 0, 128, 32, 1)
    display.text("NorthernStudios", 20, 8, 1)
    display.text("TM", 110, 6, 1)
    display.rect(14, 22, 102, 8, 1) 
    display.show()
    for i in range(100):
        display.fill_rect(15, 23, i + 1, 6, 1)
        display.show()
        time.sleep(0.005) 

def update_ui(menu_idx, active_idx, is_adj, bright_lvl, pulse=False):
    # Only update if screen is actually receiving power
    if display_state == "OFF": return
    
    display.fill(0)
    bitmaps = [PLANE_BITMAP, RACE_BITMAP, MEDIA_BITMAP, STATS_ICON, GEAR_ICON]
    labels = ["FLIGHT MODE", "RACING MODE", "MEDIA MODE", "SYS MONITOR", "SETTINGS"]
    is_active = (menu_idx == active_idx)
    
    if is_adj:
        draw_bitmap_direct(GEAR_ICON, 5, 0)
        display.text("BRIGHTNESS", 42, 4, 1)
        bar_width = int(bright_lvl * 78)
        display.rect(42, 18, 80, 8, 1)
        display.fill_rect(43, 19, bar_width, 6, 1)
        pulse_col = 1
    else:
        if is_active:
            display.fill_rect(40, 0, 88, 32, 1)
            text_col, pulse_col = 0, 0 
            status_text = f"NS:{VERSION} RDY"
        else:
            display.rect(40, 0, 88, 32, 1)
            text_col, pulse_col = 1, 1 
            status_text = "PENDING..."
            
        draw_bitmap_direct(bitmaps[menu_idx], 5, 0)
        
        if menu_idx == 3: # Console stats
            cpu_t = microcontroller.cpu.temperature
            mem_f = gc.mem_free() / 1024
            uptime = time.monotonic()
            display.text(f"CPU: {int(cpu_t)}C", 42, 1, text_col)
            display.text(f"MEM: {int(mem_f)}K", 42, 11, text_col)
            display.text(f"UP: {int(uptime)}s", 42, 21, text_col)
        else:
            display.text(labels[menu_idx], 42, 4, text_col)
            display.hline(42, 16, 80, text_col)
            display.text(status_text, 42, 20, text_col)

    if pulse: display.fill_rect(120, 2, 3, 3, pulse_col) 
    display.show()

def color_wheel(pos):
    if pos < 85: return (255 - pos * 3, pos * 3, 0)
    if pos < 170: pos -= 85; return (0, 255 - pos * 3, pos * 3)
    pos -= 170; return (pos * 3, 0, 255 - pos * 3)

# --- KEYBOARD SETUP ---
keys_pins = [microcontroller.pin.GPIO26, microcontroller.pin.GPIO27, 
             microcontroller.pin.GPIO28, microcontroller.pin.GPIO29, 
             microcontroller.pin.GPIO2,  microcontroller.pin.GPIO4, 
             microcontroller.pin.GPIO3]
keyboard.matrix = KeysScanner(pins=keys_pins, value_when_pressed=False, pull=True)
keyboard.modules = [Layers()]
keyboard.keymap = [[KC.F13, KC.F14, KC.F15, KC.F16, KC.F17, KC.F18, KC.F19],
                   [KC.N1, KC.N2, KC.N3, KC.N4, KC.N5, KC.N6, KC.N7],
                   [KC.A, KC.B, KC.C, KC.D, KC.MUTE, KC.VOLD, KC.VOLU],
                   [KC.NO]*7, [KC.NO]*7]

# --- SYSTEM VARS ---
last_pos, menu_sel, active_lay = 0, 0, 0
last_move_time = last_pulse_time = time.monotonic()
pulse_state = is_adjusting = False
current_brightness, rgb_pos = 0.5, 0

def master_loop(*args, **kwargs):
    global last_pos, menu_sel, active_lay, last_move_time, last_pulse_time, pulse_state, is_adjusting, current_brightness, rgb_pos, display_state, last_activity_time
    now = time.monotonic()
    idle_time = now - last_activity_time
    
    # RGB Always active
    rgb_pos = (rgb_pos + RGB_SPEED) % 255
    pixel[0] = color_wheel(int(rgb_pos))

    # --- POWER MANAGEMENT LOGIC ---
    if idle_time > OFF_TIMEOUT:
        if display_state != "OFF":
            display.poweroff()
            display_state = "OFF"
    elif idle_time > DIM_TIMEOUT:
        if display_state != "DIM":
            display.poweron()
            display.contrast(1)
            display_state = "DIM"
            update_ui(menu_sel, active_lay, is_adjusting, current_brightness, pulse_state)
    else:
        if display_state != "ON":
            display.poweron()
            display.contrast(255)
            display_state = "ON"
            update_ui(menu_sel, active_lay, is_adjusting, current_brightness, pulse_state)

    # 1. Wake Check for Keys
    if display_state != "ON" and (now - last_activity_time < 0.2):
        # Force Wake handled by state logic above
        pass

    # 2. Encoder Interaction
    curr_pos = encoder.position
    if curr_pos != last_pos:
        last_activity_time = now
        diff = curr_pos - last_pos
        last_move_time = now
        if not is_adjusting:
            menu_sel = (menu_sel + diff) % 5
        else:
            current_brightness = max(0.1, min(1.0, current_brightness + (diff * 0.05)))
            pixel.brightness = current_brightness
        last_pos = curr_pos
        if display_state == "ON":
            update_ui(menu_sel, active_lay, is_adjusting, current_brightness, pulse_state)

    # If screen is off, stop updating UI to save CPU
    if display_state == "OFF": return

    # 3. Dwell Selection
    if now - last_move_time > DWELL_TIME:
        if is_adjusting:
            is_adjusting = False
            pixel[0] = (255, 100, 0)
            time.sleep(0.1)
            update_ui(menu_sel, active_lay, is_adjusting, current_brightness, pulse_state)
            last_move_time = now
        elif menu_sel != active_lay:
            active_lay = menu_sel
            keyboard.active_layers = [active_lay]
            if active_lay == 4: is_adjusting = True
            pixel[0] = (0, 255, 0)
            time.sleep(0.1)
            update_ui(menu_sel, active_lay, is_adjusting, current_brightness, pulse_state)
            last_move_time = now

    # 4. Heartbeat Pulse
    if now - last_pulse_time > 1.0:
        pulse_state = not pulse_state
        last_pulse_time = now
        update_ui(menu_sel, active_lay, is_adjusting, current_brightness, pulse_state)

keyboard.before_matrix_scan = master_loop
startup_screen()
update_ui(0, 0, False, 0.5)

if __name__ == '__main__':
    keyboard.go()
